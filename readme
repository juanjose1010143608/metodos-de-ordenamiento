## Metodos de ordenamiento
Los métodos de ordenamiento son algoritmos que organizan los registros de una tabla en algún orden secuencial según un criterio dado. Este proceso se basa en el valor
e un campo dentro de un conjunto de datos y puede realizarse de manera iterativa o recursiva, según la naturaleza y la forma de ejecución del método.

A continuación se presentan ejemplos comunes de métodos de ordenamiento, junto con sus características principales y su implementación en C++:

1. Bubble Sort:
El BubbleSort es un algoritmo de ordenamiento sencillo que recorre cada elemento de la lista a ordenar, comparándolo con el siguiente y intercambiándolos si están en un orden incorrecto (n > n+1). Este proceso se repite varias veces hasta que no se realicen más intercambios, lo que indica que la lista está ordenada.

2. Selection Sort:
El Método de Ordenamiento por Selección implica la búsqueda del elemento más pequeño entre todos los elementos no ordenados y colocarlo al principio de la lista. Este proceso se repite con los elementos restantes, sin considerar aquellos que ya han sido ordenados.

3. Insertion Sort: 
Encuentra el elemento más pequeño en el arreglo y lo intercambia con el primer elemento. Encuentra el segundo elemento más pequeño y lo intercambia con el segundo elemento del arreglo.

4. Merge Sort: 
El algoritmo de Ordenamiento por Mezcla opera de manera específica. Si la longitud de la lista es 0 o 1, se considera automáticamente como ordenada. En otros casos,
el algoritmo divide la lista desordenada en dos sublistas, cada una aproximadamente de la mitad del tamaño original. Luego, ordena cada una de estas sublistas de 
manera recursiva utilizando el mismo algoritmo de Ordenamiento por Mezcla. Finalmente, fusiona las dos sublistas ordenadas en una única lista ordenada.

5. Quick Sort:
El Método de Ordenamiento Rápido, al igual que el Ordenamiento por Mezcla, es un algoritmo basado en la estrategia "divide y vencerás". En este método, se 
selecciona un elemento como pivote y se divide la matriz alrededor de ese pivote. Hay múltiples variantes de este algoritmo que eligen el pivote de diferentes 
maneras:

- Al seleccionar siempre el primer elemento como pivote.
- Al seleccionar siempre el último elemento como pivote.
- Al seleccionar un elemento aleatorio como pivote.
- Al seleccionar la mitad de la matriz como pivote.

El proceso fundamental en el Ordenamiento Rápido es la partición. Su objetivo es tomar un elemento de la matriz y colocarlo en su posición correcta en la matriz 
ordenada, garantizando que todos los elementos menores que el pivote estén antes de él, y que todos los elementos mayores que el pivote estén después de él.

6. Bucket Sort:
El método de ordenamiento Bucket Sort es una técnica de clasificación que funciona dividiendo una lista desordenada en un número finito de "cubetas" (o "buckets"). 
Cada cubeta actúa como un contenedor que puede contener un rango específico de valores. Luego, los elementos de la lista original se distribuyen en estas cubetas 
según el valor de cada elemento.

7. Shell Sort:
El Método de ordenamiento Shell es una mejora del Método de Ordenamiento por inserción ya que el Método de inserción es eficiente si la lista está casi ordenada, 
para ello el Método Shell compara elementos separados por un espacio de varias posiciones, esto permite que un elemento haga “pasos más grandes” hacia su posición 
esperada, el mismo finaliza con un Ordenamiento por inserción simple. 

8. Counting Sort:
Counting Sort es un algoritmo eficiente cuando el rango de valores de los elementos es relativamente pequeño en comparación con el número total de elementos. 
Tiene una complejidad temporal de O(n + k), donde n es el número de elementos y k es el rango de valores. Sin embargo, Counting Sort no es adecuado para ordenar 
elementos cuando el rango de valores es muy grande o si los elementos son objetos complejos.

9. Radix Sort:
Radix Sort es eficiente para ordenar números enteros con un número fijo de dígitos, ya que tiene un tiempo de ejecución lineal O(nk), donde n es el número de 
elementos y k es el número de dígitos. Sin embargo, Radix Sort puede no ser tan eficiente para ordenar números con un rango variable de dígitos o para ordenar 
elementos que no son enteros.



En cuanto a los pasos a seguir en el código, tenemos:
1. Preparación del archivo de datos: Antes de comenzar, se debe tener un archivo de datos con al menos 5000 números para ordenar. Este archivo puede contener números aleatorios o puede ser generado previamente.

2. Incluir bibliotecas necesarias: Al inicio del código, se debe asegurar de incluir las bibliotecas necesarias, como `<iostream>` para la entrada y salida estándar, y `<fstream>` para manejar archivos.

3. Definir los métodos de ordenación: Crear las funciones para cada uno de los 9 métodos de ordenación que deseas implementar. Puedes tener funciones separadas para cada método o una función genérica que recibe el método de ordenación como parámetro.

4. Abrir y leer el archivo: Utilizar la biblioteca `<fstream>` para abrir el archivo de datos y leer los números que contiene. Almacena estos números en un arreglo o vector en memoria.

5. Implementar los algoritmos de ordenación: Para cada método de ordenación, aplica el algoritmo correspondiente al arreglo de números que has leído del archivo.

6. Medir el tiempo de ejecución: Utiliza funciones como `clock()` o `chrono::high_resolution_clock` para medir el tiempo de ejecución de cada método de ordenación.

7. Escribir los resultados en un nuevo archivo: Después de ordenar los números, se deben escribir los resultados en un nuevo archivo. Puedes utilizar el mismo archivo de entrada y sobrescribirlo, o crear un nuevo archivo para cada método de ordenación.

8. Repetir el proceso: Repetir los pasos del 4 al 7 para cada método de ordenación que deseas probar.

9. Comparar resultados: Una vez que se haya ordenado los números utilizando los 9 métodos diferentes, compara los resultados para verificar que cada método produce el mismo resultado ordenado.

10. Analizar el rendimiento: Finalmente, se analiza y compara el tiempo de ejecución de cada método de ordenación para determinar cuál es más eficiente en términos de tiempo de ejecución.
